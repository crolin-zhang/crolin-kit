# 线程池库架构设计

## 整体架构

线程池库采用模块化设计，将公共API与内部实现分离，以提高代码的可维护性和可扩展性。整体架构如下：

```
+------------------+     +-------------------+     +------------------+
|                  |     |                   |     |                  |
|   用户应用程序    +---->+   线程池公共API    +---->+   线程池内部实现   |
|                  |     |                   |     |                  |
+------------------+     +-------------------+     +------------------+
                                                         |
                                                         v
                                               +------------------+
                                               |                  |
                                               |   POSIX线程库    |
                                               |                  |
                                               +------------------+
```

## 核心组件

### 1. 公共API层 (thread.h)

公共API层定义了用户可见的接口和数据类型，包括：

- **线程池句柄类型** (`thread_pool_t`) - 不透明指针类型，隐藏内部实现细节
- **任务结构** (`task_t`) - 定义任务的函数指针、参数和名称
- **公共函数** - 创建线程池、添加任务、获取任务状态和销毁线程池的函数

### 2. 内部实现层 (thread.c, thread_internal.h)

内部实现层包含线程池的具体实现，包括：

- **线程池结构** (`struct thread_pool_s`) - 包含线程池的所有状态信息
- **任务队列节点** (`task_node_t`) - 任务队列的链表节点
- **工作线程函数** - 工作线程的主循环函数
- **任务队列管理函数** - 任务入队、出队和队列销毁函数
- **同步机制** - 互斥锁和条件变量的使用

### 3. 测试层 (tests/)

测试层位于项目根目录下，包含验证线程池功能的测试程序：

- **基本功能测试** - 测试线程池的创建、任务添加和销毁
- **错误处理测试** - 测试各种错误情况的处理

### 4. 示例层 (examples/)

示例层位于项目根目录下，包含展示线程池使用方法的示例程序：

- **基本用法示例** - 展示线程池的基本使用方法
- **任务状态监控示例** - 展示如何监控任务状态

## 数据结构

### 线程池结构 (thread_pool_s)

```c
struct thread_pool_s {
    pthread_mutex_t lock;       // 互斥锁，用于保护对共享池数据的访问
    pthread_cond_t notify;      // 条件变量，用于通知工作线程有新任务或需要关闭
    pthread_t *threads;         // 工作线程标识符数组
    int thread_count;           // 池中的工作线程数量
    task_node_t *head;          // 指向任务队列头部的指针
    task_node_t *tail;          // 指向任务队列尾部的指针
    int task_queue_size;        // 队列中当前的任务数量
    int shutdown;               // 标志，指示池的关闭状态 (0: 活动, 1: 正在关闭/已关闭)
    int started;                // 已成功启动的线程数量
    char **running_task_names;  // 字符串数组，存储正在执行的任务名称
    int active_threads;         // 当前活跃的线程数量
    int completed_tasks;        // 已完成的任务数量
    int auto_adjust_enabled;    // 是否启用自动调整功能
    int min_threads;            // 自动调整的最小线程数
    int max_threads;            // 自动调整的最大线程数
    int check_interval_ms;      // 自动调整的检查间隔（毫秒）
    pthread_t adjust_thread;    // 自动调整线程
    int adjust_thread_running;  // 自动调整线程是否正在运行
};
```

### 任务结构 (task_t)

```c
typedef struct {
    void (*function)(void *arg); // 指向要执行的函数的指针
    void *arg;                   // 要传递给函数的参数
    char task_name[MAX_TASK_NAME_LEN]; // 任务的名称，用于日志记录/监控
} task_t;
```

### 任务队列节点 (task_node_t)

```c
typedef struct task_node_s {
    task_t task;              // 实际的任务数据
    struct task_node_s *next; // 指向队列中下一个任务节点的指针
} task_node_t;
```

## 工作流程

### 1. 线程池创建流程

1. 分配线程池结构内存
2. 初始化互斥锁和条件变量
3. 分配线程数组和任务名称数组
4. 创建工作线程，传递线程池指针和线程ID
5. 返回线程池句柄

### 2. 任务添加流程

1. 检查线程池和函数指针的有效性
2. 锁定互斥锁
3. 检查线程池是否正在关闭
4. 准备任务数据（函数指针、参数和名称）
5. 将任务添加到队列尾部
6. 通知一个等待的工作线程
7. 解锁互斥锁

### 3. 工作线程执行流程

1. 锁定互斥锁
2. 等待任务或关闭信号
3. 如果线程池正在关闭且队列为空，则退出
4. 从队列中取出任务
5. 更新正在运行的任务名称
6. 解锁互斥锁
7. 执行任务
8. 锁定互斥锁
9. 更新状态为空闲
10. 解锁互斥锁
11. 返回步骤1

### 4. 线程池大小调整流程

1. 检查线程池和新线程数量的有效性
2. 锁定互斥锁
3. 检查线程池是否正在关闭
4. 如果新线程数量大于当前数量：
   a. 重新分配线程数组和任务名称数组
   b. 创建新的工作线程
5. 如果新线程数量小于当前数量：
   a. 标记要移除的线程
   b. 广播通知所有工作线程
   c. 等待标记的线程退出
   d. 重新分配线程数组和任务名称数组
6. 更新线程池的线程数量
7. 解锁互斥锁

### 5. 线程池自动调整流程

1. 检查线程池和参数的有效性
2. 锁定互斥锁
3. 检查线程池是否正在关闭
4. 设置自动调整参数（最小线程数、最大线程数、检查间隔）
5. 创建自动调整线程
6. 解锁互斥锁
7. 自动调整线程定期执行以下操作：
   a. 锁定互斥锁
   b. 检查线程池负载（活跃线程数、队列任务数）
   c. 根据负载情况决定是否需要调整线程数量
   d. 如果需要调整，调用线程池大小调整函数
   e. 解锁互斥锁
   f. 等待指定的检查间隔

### 6. 线程池销毁流程

1. 检查线程池的有效性
2. 锁定互斥锁
3. 检查线程池是否已在关闭
4. 设置关闭标志
5. 如果自动调整功能已启用，停止自动调整线程
6. 广播通知所有工作线程
7. 解锁互斥锁
8. 等待所有工作线程完成
9. 销毁任务队列
10. 释放所有资源（线程数组、任务名称数组等）
11. 销毁互斥锁和条件变量
12. 释放线程池结构内存

## 同步机制

线程池库使用以下同步机制确保线程安全：

1. **互斥锁 (pthread_mutex_t)** - 保护对共享数据的访问，包括任务队列和线程池状态
2. **条件变量 (pthread_cond_t)** - 用于工作线程等待新任务或关闭信号

## 错误处理

线程池库采用以下错误处理策略：

1. **函数返回值** - 成功时返回0或有效指针，失败时返回-1或NULL
2. **参数验证** - 在函数开始处验证参数的有效性
3. **日志记录** - 使用TPOOL_LOG和TPOOL_ERROR宏记录错误和调试信息
4. **资源清理** - 在错误发生时释放已分配的资源

## 内存管理

线程池库采用以下内存管理策略：

1. **动态分配** - 使用malloc/calloc分配内存
2. **显式释放** - 使用free释放不再需要的内存
3. **所有权明确** - 明确定义谁负责释放内存（例如，工作线程负责释放任务参数）
4. **防止内存泄漏** - 在错误处理和销毁过程中释放所有分配的内存

## 扩展性考虑

线程池库的设计考虑了以下扩展性因素：

1. **模块化设计** - 公共API与内部实现分离，便于修改内部实现而不影响用户代码
2. **不透明指针** - 使用不透明指针隐藏内部实现细节，便于未来扩展内部结构
3. **清晰的接口** - 定义清晰的接口，便于添加新功能
4. **可配置性** - 通过宏定义和函数参数提供配置选项
5. **动态调整能力** - 支持在运行时动态调整线程池大小，适应不同的负载情况
6. **自适应机制** - 实现自动调整功能，根据负载自动调整资源利用
7. **性能统计** - 提供详细的统计信息，便于监控和调优

## 测试策略

线程池库采用了全面的测试策略，确保功能正确性和稳定性：

1. **单元测试** - 测试线程池的基本功能，如创建、添加任务和销毁
2. **功能测试** - 测试线程池的特定功能，如线程池大小调整和自动调整
3. **压力测试** - 测试线程池在高负载情况下的表现
4. **异常测试** - 测试线程池对异常情况的处理，如内存分配失败和无效参数
5. **随机化测试** - 使用随机参数进行测试，提高测试覆盖范围
6. **边界条件测试** - 测试线程池在边界条件下的行为，如最小/最大线程数、空任务队列等
7. **并发测试** - 测试线程池在高并发情况下的正确性和性能
